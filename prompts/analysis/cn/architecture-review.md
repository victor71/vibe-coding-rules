# 架构审查 Prompt Template

用于审查和改进系统架构的 prompt 模板。

## 场景

- 审查现有系统架构
- 识别架构问题和风险
- 提出架构改进建议
- 评估架构设计方案

## Prompt 模板

### 基础模板（架构审查）

```markdown
请审查以下系统架构：

## 架构描述
[架构概述、组件、交互]

## 系统背景
- 业务领域：[行业/场景]
- 用户规模：[日活/并发]
- 数据规模：[数据量]
- 技术栈：[技术栈]

## 审查维度

请从以下维度审查：

### 1. 架构合理性
- 组件职责是否清晰？
- 是否存在循环依赖？
- 模块划分是否合理？
- 是否符合单一职责原则？

### 2. 可扩展性
- 如何应对用户增长？
- 如何应对功能增长？
- 水平/垂直扩展能力？
- 是否需要解耦？

### 3. 可靠性
- 单点故障？
- 容错机制？
- 降级策略？
- 监控告警？

### 4. 性能
- 瓶颈在哪里？
- 缓存策略？
- 数据库设计？
- 是否需要优化？

### 5. 安全性
- 认证授权？
- 数据加密？
- 防护措施？
- 合规性？

### 6. 可维护性
- 代码清晰度？
- 文档完善度？
- 技术债务？
- 测试覆盖？

### 7. 成本
- 资源成本？
- 运维成本？
- 是否有浪费？

## 输出格式

### 评分汇总
| 维度 | 评分 | 主要问题 |
|------|------|---------|
| 架构合理性 | 4/5 | 组件职责清晰，但存在循环依赖 |
| 可扩展性 | 3/5 | ... |
... | ... | ... |

### Critical问题（必须修复）
1. [问题描述]
   - 位置：[组件/模块]
   - 影响：[严重性]
   - 建议：[具体改进方案]

### High优先级问题
...

### 改进建议
1. [建议]
   - 理由：[为什么建议]
   - 收益：[预期收益]

### 做得好的地方
- [好的设计]
```

---

### 设计方案评审模板

```markdown
请评审以下架构设计方案：

## 方案概述
[方案描述]

## 架构图
[架构图或描述]

## 评审要点

### 1. 设计合理性
- 是否符合需求？
- 组件划分是否合理？
- 是否过度设计？
- 是否存在明显缺陷？

### 2. 技术选型
- 技术选择是否合理？
- 是否考虑了替代方案？
- 团队能力是否匹配？
- 成本是否可控？

### 3. 实施可行性
- 时间估算是否合理？
- 依赖关系是否清晰？
- 风险是否识别？
- 是否有回滚方案？

### 4. 运维可行性
- 部署复杂度？
- 监控告警是否完善？
- 故障处理是否清晰？
- 文档是否完整？

### 5. 成本收益
- 成本是否合理？
- 收益是否明确？
- ROI是否可接受？

## 输出格式

### 评审结论
- [ ] 通过，可以实施
- [ ] 有条件通过（需要修改XX）
- [ ] 不通过（主要原因：XX）

### 重大问题
1. [问题]
   - 影响：[严重性]
   - 建议：[如何修改]

### 改进建议
1. [建议]
   - 优先级：High/Medium/Low

### 风险提示
1. [风险]
   - 概率：[高/中/低]
   - 应对：[如何应对]
```

---

### 重构建议模板

```markdown
请分析以下架构，提出重构建议：

## 当前架构
[架构描述]

## 痛点
- [痛点1]
- [痛点2]

## 请提供：

### 重构目标
- 解决哪些问题？
- 达到什么效果？

### 重构方案

#### 方案1: [方案名称]
- **描述**：[方案概述]
- **改动**：[需要改动的组件]
- **收益**：[预期收益]
- **成本**：[时间/风险]
- **风险**：[潜在风险]

#### 方案2: ...

### 推荐方案
- **选择**：方案X
- **理由**：[为什么推荐]
- **实施路径**：[如何实施]

### 分阶段计划
- Phase 1: [目标]
- Phase 2: [目标]
- Phase 3: [目标]
```

---

## 实际例子

### 例子 1：单体应用架构审查

**输入：**
```
架构描述：
- 单体应用（Node.js + Express）
- 直接连接PostgreSQL
- 文件存储在本地
- 使用内存session

系统背景：
- 电商网站，日活10万
- 商品表10万条，订单表100万条
- 技术栈：Node.js, PostgreSQL, Redis（仅用于缓存）
```

**AI输出：**

```markdown
# 架构审查报告

## 评分汇总
| 维度 | 评分 | 主要问题 |
|------|------|---------|
| 架构合理性 | 3/5 | 职责混乱，模块耦合严重 |
| 可扩展性 | 2/5 | 无法水平扩展，文件存储瓶颈 |
| 可靠性 | 2/5 | 单点故障，无容错机制 |
| 性能 | 3/5 | 数据库压力大，无读写分离 |
| 安全性 | 3/5 | session安全性不足 |
| 可维护性 | 3/5 | 代码耦合，难以维护 |
| 成本 | 4/5 | 成本较低 |

---

## Critical问题（必须修复）

### 1. 文件存储在本地 ❌
- **位置**：上传模块
- **影响**：Critical
  - 无法水平扩展（多实例无法共享文件）
  - 服务器故障导致文件丢失
  - 容量限制难以扩展
- **建议**：
  - 迁移到对象存储（S3/OSS）
  - 使用CDN加速访问
  - 实现文件多副本备份

### 2. 无容错机制 ❌
- **位置**：整体架构
- **影响**：Critical
  - 数据库故障导致全站不可用
  - 应用服务器故障无备用
- **建议**：
  - 数据库主从复制 + 自动故障转移
  - 应用多实例部署（至少2个）
  - 实现健康检查和自动重启

### 3. 内存Session不安全 ⚠️
- **位置**：认证模块
- **影响**：High
  - 多实例间session不共享
  - 扩容时用户需要重新登录
  - 内存有限，无法存储大量session
- **建议**：
  - 迁移到Redis存储session
  - 使用JWT token替代session
  - 实现token刷新机制

---

## High优先级问题

### 1. 无读写分离
- **位置**：数据库层
- **影响**：High
  - 读写都在主库，压力大
  - 高并发时响应慢
- **建议**：
  - PostgreSQL主从复制
  - 读写分离（写主读从）
  - 实现负载均衡

### 2. 无监控告警
- **位置**：整体架构
- **影响**：High
  - 无法及时发现故障
  - 排查困难
- **建议**：
  - 集成APM（如New Relic/DataDog）
  - 关键指标监控（响应时间、错误率、QPS）
  - 实现告警通知

### 3. 模块耦合严重
- **位置**：代码层面
- **影响**：High
  - 难以维护和扩展
  - 修改一个模块影响其他模块
- **建议**：
  - 重构为分层架构
  - 提取公共逻辑
  - 实现模块解耦

---

## Medium优先级问题

### 1. 缺少缓存策略
- **影响**：Medium
  - 数据库压力大
  - 热数据查询慢
- **建议**：
  - Redis缓存热数据（商品信息、用户信息）
  - 实现缓存预热
  - 设置合理TTL

### 2. 无异步任务处理
- **影响**：Medium
  - 邮件发送、图片处理阻塞主流程
  - 响应时间长
- **建议**：
  - 引入消息队列（RabbitMQ/Kafka）
  - 异步处理耗时任务
  - 实现任务重试机制

---

## 改进建议

### 1. 短期改进（1-2周）
1. 迁移session到Redis（2天）
2. 配置数据库主从复制（3天）
3. 添加基础监控（2天）

### 2. 中期改进（1-2月）
1. 迁移文件存储到S3（1周）
2. 实现读写分离（1周）
3. 引入消息队列（1周）
4. 代码重构分层（2周）

### 3. 长期改进（3-6月）
1. 微服务化改造（根据业务需求）
2. 服务网格（如需要）
3. 容器化部署

---

## 做得好的地方 ✅

1. **技术栈合理** - Node.js + PostgreSQL适合快速开发
2. **已使用Redis** - 虽然仅用于缓存，但基础设施已有
3. **代码结构清晰** - MVC分层，易于理解
```

---

### 例子 2：设计方案评审

**输入：**
```
方案：引入微服务架构
- 将单体拆分为5个服务
- 使用服务网格管理服务间通信
- 每个服务独立数据库

背景：
- 当前20人团队
- 日活10万
- 预计增长到100万
```

**AI输出：**

```markdown
# 设计方案评审报告

## 评审结论

**[ ] 有条件通过（需要修改XX）**

---

## 重大问题

### 1. 过早微服务化 ❌
- **影响**：Critical
  - 当前规模（日活10万，20人团队）不需要微服务
  - 微服务增加复杂度（分布式事务、服务发现、监控）
  - 团队可能缺乏运维经验
- **建议**：
  - 暂时保持单体，先优化现有架构
  - 等规模到日活50-100万再考虑微服务
  - 当前可以做的：模块化、解耦、为微服务做准备

### 2. 服务网格过度设计 ⚠️
- **影响**：High
  - 服务网格增加复杂度和学习成本
  - 当前服务数量（5个）不需要服务网格
- **建议**：
  - 使用API Gateway管理路由
  - 使用轻量级服务注册中心
  - 等服务数量>20个再考虑服务网格

---

## 改进建议

### 1. 替代方案：模块化单体
- **描述**：保持单体架构，但模块化
- **收益**：
  - 降低复杂度
  - 保持开发效率
  - 易于维护
- **成本**：低
- **实施**：
  - 1. 模块解耦（2周）
  - 2. 提取公共库（1周）
  - 3. 独立部署能力（1周）

### 2. 数据库策略
- **不推荐**：每个服务独立数据库
  - 原因：跨服务查询复杂，事务处理困难
- **推荐**：共享数据库 + 模块隔离
  - 每个模块有独立的schema
  - 通过API访问，不直接跨schema查询
  - 未来可以拆分数据库

### 3. 增量拆分策略
如果未来需要拆分，采用增量方式：
1. 识别边界清晰的模块（如支付服务）
2. 先拆分一个服务验证
3. 逐步拆分其他模块
4. 保持单体和微服务共存一段时间

---

## 风险提示

| 风险 | 概率 | 影响 | 应对 |
|------|------|------|------|
| 分布式事务复杂 | 高 | 严重 | 使用事件驱动架构，最终一致性 |
| 运维复杂度增加 | 高 | 中 | 培训团队，引入云托管服务 |
| 服务间调用延迟 | 中 | 中 | 实现缓存，优化通信协议 |
| 团队能力不足 | 高 | 严重 | 引入外部专家，逐步迁移 |
```

---

### 例子 3：重构建议

**输入：**
```
当前架构：
- 单体应用，代码耦合严重
- 所有业务逻辑在Controller层
- 直接SQL查询分散在代码各处
- 无测试覆盖

痛点：
- 修改一个bug影响多个功能
- 新功能开发慢
- 难以测试
```

**AI输出：**

```markdown
# 架构重构建议

## 重构目标
- 代码解耦，模块独立
- 提高可测试性
- 提升开发效率
- 降低维护成本

---

## 重构方案

### 方案1: 三层架构 + Repository
- **描述**：
  - Controller层：处理HTTP请求，调用Service
  - Service层：业务逻辑
  - Repository层：数据访问
- **改动**：
  - 提取Service层
  - 创建Repository封装数据库访问
  - 移除Controller中的业务逻辑
- **收益**：
  - 职责清晰，易于理解
  - 可测试性提高（可mock Repository）
  - 代码复用性提高
- **成本**：
  - 时间：2-3周
  - 风险：Medium（可能引入bug）
- **风险**：
  - 重构期间可能引入bug
  - 团队需要适应新架构

### 方案2: DDD（领域驱动设计）
- **描述**：
  - 按业务领域划分模块
  - 每个模块包含完整的业务逻辑
  - 模块间通过接口通信
- **改动**：
  - 识别领域边界
  - 重构为领域模块
  - 实现事件驱动通信
- **收益**：
  - 业务逻辑集中，易于维护
  - 模块独立，可扩展
  - 团队按领域分工
- **成本**：
  - 时间：4-6周
  - 风险：High（架构变化大）
- **风险**：
  - 学习曲线陡峭
  - 重构周期长
  - 可能过度设计

### 方案3: 模块化重构（推荐）
- **描述**：
  - 保持三层架构
  - 按业务模块组织代码
  - 模块间依赖单向
- **改动**：
  - 三层架构（方案1）
  - 按业务模块组织目录
  - 提取公共逻辑
- **收益**：
  - 平衡复杂度和收益
  - 快速见效
  - 为未来微服务做准备
- **成本**：
  - 时间：3-4周
  - 风险：Low
- **风险**：
  - 较低，改动渐进

---

## 推荐方案：方案3 - 模块化重构

**理由：**
1. **平衡复杂度** - 不过度设计，但解决核心问题
2. **快速见效** - 3-4周完成，立即改善
3. **低风险** - 渐进式重构，易于回滚
4. **未来准备** - 为未来微服务化打下基础

**Trade-off：**
- 选择：快速、低风险、渐进式
- 放弃：完整的DDD架构（可能需要）
- 接受：中间状态（模块化但不是完全解耦）

---

## 分阶段计划

### Phase 1: 基础重构（1-2周）
**目标**：建立三层架构

**任务**：
- [ ] 提取Service层（3天）
- [ ] 创建Repository层（2天）
- [ ] 移除Controller业务逻辑（2天）
- [ ] 添加基础测试（3天）

**交付物**：
- 三层架构代码
- 单元测试（覆盖率>50%）

---

### Phase 2: 模块化（1-2周）
**目标**：按业务模块组织代码

**任务**：
- [ ] 识别业务模块（用户、商品、订单...）（2天）
- [ ] 重构目录结构（3天）
- [ ] 解耦模块依赖（3天）
- [ ] 补充测试（2天）

**交付物**：
- 模块化代码结构
- 集成测试
- 模块依赖图

---

### Phase 3: 优化完善（1周）
**目标**：提高质量和可维护性

**任务**：
- [ ] 代码review和优化（2天）
- [ ] 补充文档（2天）
- [ ] 性能优化（2天）
- [ ] 添加监控（1天）

**交付物**：
- 完整文档
- 监控告警
- 性能报告

---

## 关键决策点

### 1. 是否立即拆分微服务？
**决策**：不拆分
**理由**：当前规模不需要，增加复杂度
**触发条件**：日活>50万 或 团队>50人

### 2. 是否引入事件驱动？
**决策**：暂不引入
**理由**：当前需求不需要异步解耦
**触发条件**：需要解耦模块 或 有跨模块事务

### 3. 如何处理数据访问？
**决策**：先使用ORM/Repository
**理由**：提高开发效率和可维护性
**未来**：如需性能优化，再优化SQL
```

---

## 关键原则

### 1. 根据规模选择架构

不要盲目追求"先进"架构：
- 小规模（<10人，<10万日活）：单体 + 模块化
- 中规模（10-50人，10-100万日活）：模块化 + 部分微服务
- 大规模（>50人，>100万日活）：微服务架构

### 2. 渐进式重构

不要推倒重来：
- 识别痛点，逐个解决
- 保持系统可用
- 分阶段验证

### 3. 避免过度设计

YAGNI原则（You Aren't Gonna Need It）：
- 只做当前需要的
- 预留扩展空间，但不提前实现

---

## 参考资料

### 架构模式
- **单体架构** - 简单、快速
- **微服务架构** - 可扩展、复杂
- **事件驱动架构** - 解耦、异步
- **CQRS** - 读写分离

### 相关文档
- [02-solution-design.md](../phases/02-solution-design.md) - 方案设计
- [solution-design.md](./solution-design.md) - 方案设计Prompt
