# Optimization Prompt Template

性能优化的 prompt 模板。

## 场景

- 数据库查询优化
- 算法优化
- 缓存策略
- 减少内存使用
- 加速慢接口

## Prompt 模板

```
优化 [组件/区域] 以达到 [目标：速度/内存/吞吐量]。

当前性能：
- [基准测试结果或慢速描述]
- [已知的特定瓶颈，如有]

目标：
- [期望的性能指标]

上下文：
- [该组件如何使用]
- [约束：不能更改 DB schema，必须保持 API 兼容性等]

步骤：
1. 性能分析并识别瓶颈
2. 提出优化策略
3. 实施更改
4. 添加基准测试以验证改进
5. 确保现有测试的正确性

要求：
- 保持向后兼容
- 不要为了速度牺牲正确性
- 添加解释优化的注释
```

## 实际例子

### 例子 1：优化慢 API 响应

```
优化 /api/users 端点。目前大数据集需要 5-10 秒。

当前性能：
- 响应时间：1000+ 用户需要 5-10s
- 数据库查询：1000+ 查询（N+1 问题）
- 内存使用：由于加载所有数据而很高

目标：
- 响应时间：1000+ 用户 <1s
- 数据库查询：<10 查询
- 内存使用：通过流式结果减少

上下文：
- 该端点由管理仪表板使用
- 返回带有配置文件数据的分页用户列表
- 当前加载所有用户，然后过滤

要求：
- 保持相同的 API 契约
- 保持分页
- 不破坏现有过滤器

步骤：
1. 读取当前实现（api/users.py）
2. 识别 N+1 查询问题
3. 使用 JOIN 或子查询进行优化
4. 如需要，添加数据库索引
5. 流式结果而不是加载所有
6. 添加优化前/后的基准测试
7. 确保测试仍然通过
```

### 例子 2：减少内存使用

```
优化图像处理服务以减少内存使用。

当前性能：
- 处理 100 张图像：2GB RAM 使用量
- 大批次经常出现 OOM 错误
- 图像完全加载到内存中

目标：
- 处理 100 张图像：<500MB RAM
- 处理 500+ 图像的批次
- 以块或流式处理图像

上下文：
- 服务处理上传的图像
- 应用调整大小、水印、压缩
- 当前将完整图像加载到内存
- 使用 PIL (Pillow)

要求：
- 保持图像质量
- 保持相同的 API
- 支持异步处理

步骤：
1. 使用 memory_profiler 分析内存使用
2. 识别内存泄漏或分配
3. 以块或流式处理图像
4. 重用图像缓冲区
5. 添加内存监控
6. 添加内存使用基准测试
7. 确保保持视觉质量
```

## 优化策略

### 数据库优化

```
优化 [区域] 中的数据库查询。

检查：
- N+1 查询问题
- 缺少索引
- 低效的 JOIN
- 不必要的数据获取
- 次优的 WHERE 子句

优化后，添加：
- EXPLAIN ANALYZE 优化前/后输出
- 索引使用统计
- 查询时间基准测试
```

### 算法优化

```
优化 [算法/函数] 以获得更好的性能。

当前实现：[描述]
时间复杂度：[如已知]

目标：
- 如可能，改善时间复杂度
- 减少常数因子
- 如适用，考虑缓存结果

优化后：
- 添加优化前/后的基准测试比较
- 记录算法改进
- 确保边界情况的正确性
```

### 缓存策略

```
为 [组件] 添加缓存以提高性能。

当前性能：[描述慢速]
缓存目标：[应该缓存什么]

要求：
- 缓存失效策略
- 不同数据的 TTL（存活时间）
- 缓存命中/未命中指标
- 缓存失败时的回退

实施：
1. 选择缓存解决方案（Redis、内存等）
2. 缓存键设计
3. 失效逻辑
4. 回退处理
5. 指标和监控
6. 缓存行为的测试
```

## 性能分析 Prompt

### 1. 识别瓶颈

```
对 [组件] 进行性能分析以识别瓶颈。

使用：
- Python 的 cProfile 或 py-spy
- JavaScript 的 Chrome DevTools
- 如可用，使用 flamegraphs

提供：
1. 前5个最慢的函数/方法
2. 内存使用模式
3. I/O 瓶颈（DB、网络、磁盘）
4. 建议的优化优先级
```

### 2. 基准测试

```
为 [组件] 创建基准测试。

定义：
- 关键性能指标（延迟、吞吐量、内存）
- 测试场景（小型、中型、大型数据集）
- 基准性能

实施：
1. 使用 [pytest-benchmark、benchmark.js 等] 的基准测试套件
2. 多个测试用例
3. 统计显著性（运行多次迭代）

输出：
- 基准指标
- markdown 表格中的基准测试结果
- 如可能，提供图表
```

## 常见优化模式

### 1. 批量操作
```
不要这样：
for item in items:
    save_item(item)  # 单独的 DB 调用

这样：
save_items(items)  # 单个批量操作
```

### 2. 惰性加载
```
不要这样：
def get_data():
    data = heavy_computation()
    return data

这样：
def get_data():
    if not hasattr(get_data, '_cached'):
        get_data._cached = heavy_computation()
    return get_data._cached
```

### 3. 并行处理
```
不要这样：
for item in items:
    process(item)  # 顺序

这样：
with ThreadPoolExecutor() as executor:
    executor.map(process, items)  # 并行
```

### 4. 预计算
```
不要在每个请求上计算：
def get_report():
    data = compute_heavy_report()
    return data

这样：
# 预计算并缓存
def get_report():
    return load_from_cache() or compute_heavy_report()
```

## 优化检查清单

```
检查代码的优化机会：

算法：
□ 我们能改善时间复杂度吗？
□ 我们能减少常数因子吗？
□ 我们在做不必要的工作吗？

数据库：
□ 我们有 N+1 查询吗？
□ 索引被使用了吗？
□ 我们能减少获取的数据吗？

内存：
□ 我们是否不必要地持有引用？
□ 我们能以流式加载全部吗？
□ 有内存泄漏吗？

缓存：
□ 我们能缓存昂贵的计算吗？
□ 我们能缓存数据库结果吗？
□ 缓存正确失效吗？

I/O：
□ 我们在做冗余的网络调用吗？
□ 我们能批量操作吗？
□ 我们能使用异步 I/O 吗？
```
