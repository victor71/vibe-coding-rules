# Phase 2: 方案设计

## 🎯 目标

在动工之前，设计多个技术方案，对比选择最优解，确保可行性和风险可控。

**核心价值：**
- 避免选错技术栈/架构
- 识别潜在坑点
- 明确实施路径
- 为后续开发提供蓝图

---

## 🏗️ 方案设计框架

### 输入 → 处理 → 输出

```
输入：
- 需求文档（来自Phase 1）
- 约束条件（技术/时间/资源）
- 现有系统架构

处理：
- 分析需求的技术挑战
- 生成2-3个备选方案
- 评估每个方案的优缺点
- 选择最优方案

输出：
- 技术方案文档
- 架构图/设计图
- 实施计划
- 风险评估
```

---

## 🎨 方案设计思维模型

### 方案维度

| 维度 | 说明 | 检查问题 |
|------|------|---------|
| **功能性** | 是否满足所有需求？ | 遗漏了什么？ |
| **性能** | 是否满足性能目标？ | 瓶颈在哪里？ |
| **可扩展性** | 能否应对增长？ | 如何水平/垂直扩展？ |
| **可维护性** | 代码是否清晰？ | 后续是否容易修改？ |
| **安全性** | 是否有安全风险？ | 如何防范？ |
| **成本** | 开发/运维成本如何？ | 有无更便宜的方案？ |
| **时间** | 是否能在期限内完成？ | 关键路径是什么？ |
| **兼容性** | 是否兼容现有系统？ | 需要哪些改动？ |

### 方案类型

| 类型 | 适用场景 | 特点 |
|------|---------|------|
| **渐进式** | 改造现有系统 | 低风险，渐进迭代 |
| **重构式** | 系统技术债务严重 | 彻底解决，风险高 |
| **混合式** | 部分新功能/部分改造 | 平衡风险和效果 |
| **分布式** | 大规模/高并发 | 复杂度高，可扩展 |
| **集中式** | 小规模/简单逻辑 | 开发快，可扩展性差 |

---

## 📋 方案设计检查清单

### 方案文档应包含

**1. 需求回顾**
- [ ] 核心目标
- [ ] 关键需求
- [ ] 约束条件

**2. 技术挑战**
- [ ] 主要技术难点
- [ ] 性能瓶颈
- [ ] 安全风险

**3. 方案选项**
- [ ] 方案A：[名称]
- [ ] 方案B：[名称]
- [ ] 方案C：[名称]

**4. 方案对比**
| 维度 | 方案A | 方案B | 方案C |
|------|-------|-------|-------|
| 功能完整性 | ✅ | ✅ | ⚠️ |
| 性能 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 开发成本 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 风险 | 低 | 中 | 高 |
| 推荐度 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |

**5. 推荐方案**
- [ ] 选择方案X的原因
- [ ] 关键决策点
- [ ] Trade-off说明

**6. 架构设计**
- [ ] 系统架构图
- [ ] 数据流图
- [ ] 时序图（如需要）
- [ ] 数据库schema（如需要）

**7. 实施计划**
- [ ] 分阶段计划（Phase 1/2/3...）
- [ ] 每阶段交付物
- [ ] 时间估算
- [ ] 依赖关系

**8. 风险评估**
- [ ] 高风险项 + 应对策略
- [ ] 回滚方案
- [ ] 降级方案

---

## 🤖 AI辅助方案设计

### Prompt 1：生成备选方案

```markdown
请为以下需求设计2-3个技术方案：

## 需求
[需求描述]

## 约束条件
- 技术栈：[现有技术栈]
- 时间：[时间限制]
- 资源：[资源限制]

## 要求
每个方案包含：
1. 方案名称和简短描述
2. 架构概述（用文字说明）
3. 关键技术选型
4. 优点（3-5个）
5. 缺点（3-5个）
6. 工作量估算（低/中/高）
7. 主要风险

格式要求：
- 使用表格对比方案
- 推荐最优方案并说明理由
- 用简洁的技术术语
```

**示例输出：**

```markdown
## 方案对比

| 维度 | 方案A: REST API | 方案B: GraphQL | 方案C: gRPC |
|------|----------------|---------------|------------|
| 架构 | 传统REST | 单一endpoint | 高性能RPC |
| 优点 | 成熟生态、易于理解 | 按需查询、减少over-fetching | 高性能、强类型 |
| 缺点 | over-fetching/under-fetching | 复杂度高、学习曲线 | 不适合浏览器直连 |
| 开发成本 | 低 | 中 | 中高 |
| 性能 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 学习曲线 | ⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 推荐度 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |

## 推荐：方案B - GraphQL

**推荐理由：**
1. 前端需求多变，GraphQL灵活性更好
2. 减少网络请求，提升用户体验
3. 现有团队有一定GraphQL经验
4. 与React生态集成良好

**主要风险：**
1. 复杂查询可能性能问题 → 需要查询深度限制
2. N+1问题 → 需要DataLoader优化
3. 缓存复杂 → 需要缓存策略

**应对策略：**
1. 使用查询复杂度限制（如最大深度10层）
2. 集成DataLoader进行批量加载
3. 使用Apollo Client缓存 + CDN缓存
```

---

### Prompt 2：方案深度评估

```markdown
请深入评估以下技术方案：

## 方案描述
[方案描述]

## 评估维度
请从以下维度评估方案：

1. **功能性** - 是否满足所有需求？是否有限制？
2. **性能** - 响应时间、吞吐量、资源消耗预期
3. **可扩展性** - 水平扩展能力、垂直扩展空间
4. **可维护性** - 代码清晰度、文档需求、后续修改成本
5. **安全性** - 潜在安全风险、防范措施
6. **兼容性** - 与现有系统集成难度、迁移成本
7. **成本** - 开发成本、运维成本、授权成本
8. **时间** - 开发周期、上线时间、回滚时间

对每个维度：
- 评分（1-5分，5=最好）
- 说明评分理由
- 列出潜在问题和改进建议

## 输出格式
使用表格汇总评分，然后用文字说明关键点。
```

---

### Prompt 3：架构设计

```markdown
请为以下方案设计系统架构：

## 需求
[需求描述]

## 推荐方案
[选定的方案]

## 请提供：
1. **系统架构图**（用ASCII或描述）
   - 核心组件
   - 组件间交互
   - 数据流向

2. **组件职责说明**
   - 每个组件的职责
   - 接口定义（API/消息格式）
   - 依赖关系

3. **数据设计**
   - 数据库schema（如涉及）
   - 缓存策略（如需要）
   - 数据一致性方案

4. **关键技术选型说明**
   - 为什么选择X技术而不是Y？
   - 有无替代方案？为什么不选？

5. **扩展性设计**
   - 如何应对用户增长？
   - 如何应对数据增长？
   - 如何应对功能扩展？
```

---

### Prompt 4：风险评估

```markdown
请识别以下方案的风险：

## 方案描述
[方案描述]

## 请识别：
1. **技术风险**（如：不成熟的技术、性能瓶颈、兼容性问题）
2. **业务风险**（如：需求理解错误、用户体验差）
3. **资源风险**（如：人力不足、时间不够）
4. **依赖风险**（如：第三方服务不稳定、关键人员离职）
5. **迁移风险**（如：数据丢失、业务中断）

对每个风险：
- 评级：Critical/High/Medium/Low
- 概率：高/中/低
- 影响：严重/中等/轻微
- 应对策略：如何降低概率或减轻影响？
- 触发条件：什么情况下触发Plan B？
```

**示例输出：**

```markdown
## 风险评估

### Critical风险

#### 风险1：数据迁移失败
- **评级：** Critical
- **概率：** 中
- **影响：** 严重（数据丢失）
- **应对策略：**
  1. 迁移前完整备份
  2. 灰度迁移（先10% → 50% → 100%）
  3. 保留旧数据库2周以便回滚
  4. 每次迁移后验证数据完整性
- **触发条件：** 迁移后验证失败或出现异常

### High风险

#### 风险2：第三方支付服务不稳定
- **评级：** High
- **概率：** 中
- **影响：** 严重（交易失败）
- **应对策略：**
  1. 集成备用支付服务（Stripe作为PayPal备用）
  2. 实现支付重试机制（最多3次）
  3. 添加支付状态监控，异常告警
  4. 提供手动处理流程（客服介入）
- **触发条件：** 支付失败率 > 5%

### Medium风险

#### 风险3：并发导致的资源竞争
- **评级：** Medium
- **概率：** 高
- **影响：** 中等（偶尔失败）
- **应对策略：**
  1. 使用分布式锁（Redis）
  2. 乐观锁 + 重试
  3. 限流保护
- **触发条件：** QPS > 1000

### Low风险

#### 风险4：团队学习成本
- **评级：** Low
- **概率：** 中
- **影响：** 轻微（开发效率暂时降低）
- **应对策略：**
  1. 提前技术分享会
  2. 提供详细文档
  3. Code Review把关
- **触发条件：** 无
```

---

## 📐 架构设计方法

### 常见架构模式

#### 1. 分层架构（Layered Architecture）

```
┌─────────────────┐
│   Presentation  │ ← UI层
├─────────────────┤
│   Business      │ ← 业务逻辑层
├─────────────────┤
│   Persistence   │ ← 数据访问层
├─────────────────┤
│   Database      │ ← 数据库
└─────────────────┘
```

**适用场景：**
- 传统CRUD应用
- 中小型项目
- 团队熟悉DDD

**优点：**
- 清晰的职责分离
- 易于测试
- 易于理解

**缺点：**
- 可能过于严格
- 跨层调用困难

---

#### 2. 微服务架构（Microservices）

```
┌──────────┐  ┌──────────┐  ┌──────────┐
│ Service A│  │Service B │  │Service C │
└──────────┘  └──────────┘  └──────────┘
      │            │            │
      └────────────┼────────────┘
                   │
            ┌──────┴──────┐
            │   Gateway   │
            └─────────────┘
                   │
            ┌──────┴──────┐
            │  Message    │
            │   Queue     │
            └─────────────┘
```

**适用场景：**
- 大型系统
- 高并发
- 多团队协作

**优点：**
- 独立部署
- 技术栈灵活
- 故障隔离

**缺点：**
- 分布式复杂度
- 运维成本高
- 调试困难

---

#### 3. 事件驱动架构（Event-Driven）

```
┌──────────┐    ┌──────────┐    ┌──────────┐
│ Producer │───▶│  Event   │───▶│Consumer  │
└──────────┘    │  Bus     │    └──────────┘
                └──────────┘
                     │
                ┌────┴────┐
                │Consumer2│
                └─────────┘
```

**适用场景：**
- 异步处理
- 高解耦需求
- 流处理

**优点：**
- 松耦合
- 可扩展
- 异步处理

**缺点：**
- 复杂度高
- 事务处理困难
- 调试困难

---

#### 4. CQRS架构（Command Query Responsibility Segregation）

```
                    ┌─────────────┐
                    │  Command    │
                    │   Handler    │
┌──────────┐        └──────┬──────┘
│   Write  │ ────────────────▶
│   Side   │               ┌──┴──┐
└──────────┘               │ DB  │
                           └─┬───┘
┌──────────┐                 │
│   Read   │ ◀────────────────┘
│   Side   │
└──────────┘
```

**适用场景：**
- 读多写少
- 复杂查询
- 高性能要求

**优点：**
- 读写分离
- 性能优化
- 可扩展

**缺点：**
- 复杂度高
- 数据同步问题
- 开发成本

---

### 数据库设计

#### Schema设计原则

1. **规范化** - 避免数据冗余
2. **索引** - 合理创建索引
3. **分表** - 大表拆分
4. **分区** - 按时间/范围分区
5. **读写分离** - 主从复制

#### Prompt示例

```markdown
请为以下需求设计数据库schema：

## 需求
[需求描述]

## 要求
1. 设计表结构（字段、类型、约束）
2. 说明索引策略
3. 考虑数据量和增长
4. 说明是否需要分表/分区
5. 提供ER图（文字描述）

## 现有表
[现有表结构，如有]
```

---

## 🗓️ 实施计划

### 分阶段实施

#### Phase 1: POC验证（1-2周）

**目标：** 验证核心方案可行性

**任务：**
- [ ] 搭建技术原型
- [ ] 验证关键技术选型
- [ ] 性能基准测试
- [ ] 识别潜在坑点

**交付物：**
- POC代码
- 性能测试报告
- 风险评估更新

---

#### Phase 2: MVP开发（2-4周）

**目标：** 完成核心功能

**任务：**
- [ ] 核心组件开发
- [ ] API接口实现
- [ ] 基础测试
- [ ] 部署环境准备

**交付物：**
- 可运行的MVP
- API文档
- 测试报告

---

#### Phase 3: 生产就绪（2-4周）

**目标：** 达到生产标准

**任务：**
- [ ] 完善所有功能
- [ ] 性能优化
- [ ] 安全加固
- [ ] 监控告警
- [ ] 文档完善

**交付物：**
- 生产环境部署
- 完整文档
- 运维手册

---

### Prompt示例

```markdown
请为以下方案制定详细的实施计划：

## 方案概述
[方案描述]

## 要求
1. 分3个阶段（POC → MVP → Production）
2. 每个阶段列出：
   - 目标
   - 关键任务（按优先级排序）
   - 交付物
   - 时间估算
   - 依赖关系
3. 识别关键路径（critical path）
4. 识别可以并行的任务

## 约束条件
- 团队规模：X人
- 时间限制：X周
- 技术栈：[现有技术栈]
```

---

## ✅ 最佳实践

### 1. 方案设计原则

**KISS（Keep It Simple, Stupid）**
- 优先选择简单方案
- 避免过度设计
- 复杂度随需求增长

**YAGNI（You Aren't Gonna Need It）**
- 不要设计暂时不需要的功能
- 避免过度抽象
- 保持架构轻量

**DRY（Don't Repeat Yourself）**
- 提取公共逻辑
- 避免代码重复
- 建立可复用组件

---

### 2. 技术选型标准

**选择标准：**
1. **团队熟悉度** - 是否有人用过？
2. **生态成熟度** - 是否有稳定社区？
3. **学习成本** - 团队能否快速上手？
4. **性能需求** - 是否满足性能要求？
5. **兼容性** - 是否与现有系统集成？
6. **维护成本** - 长期维护成本如何？

**决策矩阵：**

| 技术 | 团队熟悉度 | 生态 | 性能 | 学习成本 | 总分 |
|------|----------|------|------|---------|------|
| A    | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 4.0 |
| B    | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 3.75 |
| C    | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | 3.25 |

---

### 3. Trade-off思维

**常见的Trade-off：**

| 维度A | 维度B | Trade-off |
|-------|-------|-----------|
| 性能 | 开发速度 | 高性能往往需要更多时间 |
| 可扩展性 | 复杂度 | 高扩展性增加复杂度 |
| 灵活性 | 稳定性 | 过于灵活可能不稳定 |
| 通用性 | 专用性 | 通用方案可能不如专用高效 |

**决策方法：**
1. 明确优先级（什么最重要？）
2. 接受Trade-off（没有完美方案）
3. 记录决策理由（便于回顾）

---

### 4. 原型先行

**POC的作用：**
- 验证可行性
- 识别坑点
- 评估性能
- 降低风险

**POC vs MVP：**

| 特征 | POC | MVP |
|------|-----|-----|
| 目标 | 验证可行性 | 可用产品 |
| 代码质量 | 粗糙 | 生产级 |
| 完整性 | 部分功能 | 核心功能完整 |
| 交付物 | 概念验证 | 可发布版本 |

---

### 5. 文档驱动设计

**设计文档应包含：**
1. 方案概述
2. 架构图
3. API定义
4. 数据模型
5. 关键决策
6. 风险评估
7. 实施计划

**文档格式建议：**
```markdown
# 技术方案：[名称]

## 背景
[为什么需要这个方案]

## 需求
[需要解决的问题]

## 方案概述
[一句话描述方案]

## 架构设计
[架构图 + 说明]

## 技术选型
[选择原因]

## 实施计划
[分阶段计划]

## 风险评估
[风险 + 应对]

## 决策记录
[关键决策及理由]
```

---

## 📚 参考资料

### 方法论
- **架构决策记录（ADR）** - 记录架构决策
- **技术雷达** - 评估新技术
- **权衡分析法** - 对比方案

### 工具
- **C4模型** - 架构绘图
- **Mermaid** - 图表生成
- **Draw.io** - 在线绘图

---

## 🚀 案例示例

### 案例：搜索系统优化

**需求：**
- 当前搜索响应时间5-10秒
- 目标：<1秒
- 支持1000 QPS

**方案对比：**

| 方案 | 描述 | 优点 | 缺点 | 推荐 |
|------|------|------|------|------|
| A | 优化现有SQL | 改动小 | 效果有限 | ❌ |
| B | 添加Redis缓存 | 简单快速 | 数据不一致 | ⭐⭐ |
| C | 迁移到Elasticsearch | 性能优秀 | 迁移成本高 | ⭐⭐⭐⭐⭐ |
| D | 混合方案（Redis+ES） | 平衡方案 | 复杂度高 | ⭐⭐⭐⭐ |

**推荐：方案C - Elasticsearch**

**理由：**
1. 专门针对搜索优化，性能提升明显
2. 团队有ES经验
3. 后续可扩展（全文搜索、聚合等）

**实施计划：**
- Week 1: POC验证ES性能
- Week 2-3: 数据迁移 + API改造
- Week 4: 性能优化 + 监控
- Week 5: 灰度发布 + 监控

**风险：**
- 数据迁移可能失败 → 备份 + 灰度迁移
- ES运维复杂 → 使用托管服务（AWS ES）

---

**下一阶段：** [03-code-development.md](03-code-development.md)

**回到总览：** [README.md](../README.md)
